/**
 * Property-Based Tests for Summary Output Formatting
 * 
 * These tests use fast-check to verify properties hold across many randomly generated inputs.
 * 
 * **Validates: Requirements 3.4**
 * 
 * Property 6: Summary Output Formatting
 * For any non-empty summary generated by the AI provider, the formatted output SHALL
 * contain the header emoji (üßµ), topic bullet points (‚Ä¢), and the open questions
 * section (‚ùì).
 * 
 * @module summary/summary-formatter.property.test
 */

import * as fc from 'fast-check';
import {
  SummaryFormatter,
  EMOJI,
  DEFAULT_HEADER,
  OPEN_QUESTIONS_HEADER,
  createSummaryFormatter,
} from './summary-formatter';

// ============================================================================
// Arbitrary Generators
// ============================================================================

/**
 * Generate random topic strings (non-empty, no newlines in middle)
 * Topics are typically short phrases describing discussion points
 */
const topicArbitrary: fc.Arbitrary<string> = fc.string({ minLength: 5, maxLength: 100 })
  .filter(s => s.trim().length > 0)
  .map(s => s.replace(/[\n\r]/g, ' ').trim());

/**
 * Generate random question strings (end with ? or start with question words)
 */
const questionArbitrary: fc.Arbitrary<string> = fc.oneof(
  // Questions ending with ?
  fc.string({ minLength: 5, maxLength: 80 })
    .filter(s => s.trim().length > 0)
    .map(s => s.replace(/[\n\r?]/g, ' ').trim() + '?'),
  // Questions starting with question words
  fc.tuple(
    fc.constantFrom('What', 'How', 'Why', 'When', 'Where', 'Who', 'Should', 'Could', 'Would', 'Is there', 'Are there'),
    fc.string({ minLength: 5, maxLength: 60 }).filter(s => s.trim().length > 0)
  ).map(([prefix, rest]) => `${prefix} ${rest.replace(/[\n\r?]/g, ' ').trim()}?`)
);

/**
 * Generate random AI summary output with topics only (no questions section)
 */
const topicsOnlySummaryArbitrary: fc.Arbitrary<string> = fc.array(topicArbitrary, { minLength: 1, maxLength: 10 })
  .map(topics => topics.map((t, i) => `${i + 1}. ${t}`).join('\n'));

/**
 * Generate random AI summary output with topics and questions section
 */
const topicsAndQuestionsSummaryArbitrary: fc.Arbitrary<string> = fc.tuple(
  fc.array(topicArbitrary, { minLength: 1, maxLength: 8 }),
  fc.array(questionArbitrary, { minLength: 1, maxLength: 5 })
).map(([topics, questions]) => {
  const topicLines = topics.map((t, i) => `${i + 1}. ${t}`).join('\n');
  const questionLines = questions.map((q, i) => `${i + 1}. ${q}`).join('\n');
  return `${topicLines}\n\nOpen Questions:\n${questionLines}`;
});

/**
 * Generate random AI summary output with bullet points
 */
const bulletPointSummaryArbitrary: fc.Arbitrary<string> = fc.array(topicArbitrary, { minLength: 1, maxLength: 10 })
  .map(topics => topics.map(t => `‚Ä¢ ${t}`).join('\n'));

/**
 * Generate random AI summary output with dashes
 */
const dashSummaryArbitrary: fc.Arbitrary<string> = fc.array(topicArbitrary, { minLength: 1, maxLength: 10 })
  .map(topics => topics.map(t => `- ${t}`).join('\n'));

/**
 * Generate random AI summary output with asterisks
 */
const asteriskSummaryArbitrary: fc.Arbitrary<string> = fc.array(topicArbitrary, { minLength: 1, maxLength: 10 })
  .map(topics => topics.map(t => `* ${t}`).join('\n'));

/**
 * Generate random AI summary output with mixed formatting
 */
const mixedFormatSummaryArbitrary: fc.Arbitrary<string> = fc.tuple(
  fc.array(topicArbitrary, { minLength: 1, maxLength: 5 }),
  fc.array(questionArbitrary, { minLength: 0, maxLength: 3 })
).map(([topics, questions]) => {
  const formats = ['‚Ä¢ ', '- ', '* ', '1. ', ''];
  const topicLines = topics.map((t, i) => `${formats[i % formats.length]}${t}`).join('\n');
  
  if (questions.length === 0) {
    return topicLines;
  }
  
  const questionLines = questions.map((q, i) => `${formats[i % formats.length]}${q}`).join('\n');
  return `Summary:\n${topicLines}\n\nQuestions:\n${questionLines}`;
});

/**
 * Generate any valid non-empty AI summary output
 */
const nonEmptySummaryArbitrary: fc.Arbitrary<string> = fc.oneof(
  topicsOnlySummaryArbitrary,
  topicsAndQuestionsSummaryArbitrary,
  bulletPointSummaryArbitrary,
  dashSummaryArbitrary,
  asteriskSummaryArbitrary,
  mixedFormatSummaryArbitrary
);

/**
 * Generate random AI summary output that explicitly contains questions
 * (to test the open questions section appears)
 */
const summaryWithQuestionsArbitrary: fc.Arbitrary<string> = fc.tuple(
  fc.array(topicArbitrary, { minLength: 1, maxLength: 5 }),
  fc.array(questionArbitrary, { minLength: 1, maxLength: 5 })
).map(([topics, questions]) => {
  const topicLines = topics.map((t, i) => `${i + 1}. ${t}`).join('\n');
  const questionLines = questions.map((q, i) => `${i + 1}. ${q}`).join('\n');
  return `Topics:\n${topicLines}\n\nOpen Questions:\n${questionLines}`;
});

// ============================================================================
// Property Tests
// ============================================================================

/**
 * **Validates: Requirements 3.4**
 * 
 * Property 6: Summary Output Formatting
 * 
 * For any non-empty summary generated by the AI provider, the formatted output SHALL
 * contain the header emoji (üßµ), topic bullet points (‚Ä¢), and the open questions
 * section (‚ùì).
 */
describe('Property Tests: Summary Output Formatting', () => {
  let formatter: SummaryFormatter;

  beforeEach(() => {
    formatter = createSummaryFormatter();
  });

  describe('Property 6: Summary Output Formatting', () => {
    /**
     * **Validates: Requirements 3.4**
     * 
     * For any non-empty summary, the formatted output SHALL contain
     * the header emoji (üßµ).
     * 
     * Property: format(nonEmptySummary).includes('üßµ') === true
     */
    it('should contain header emoji (üßµ) for any non-empty summary', () => {
      fc.assert(
        fc.property(nonEmptySummaryArbitrary, (rawSummary: string) => {
          const formatted = formatter.format(rawSummary);
          
          // Formatted output must contain the header emoji
          expect(formatted).toContain(EMOJI.HEADER);
          
          // Header should appear at the start of the output
          expect(formatted.startsWith(EMOJI.HEADER)).toBe(true);
          
          return true;
        }),
        { numRuns: 100, verbose: true }
      );
    });

    /**
     * **Validates: Requirements 3.4**
     * 
     * For any non-empty summary, the formatted output SHALL contain
     * topic bullet points (‚Ä¢).
     * 
     * Property: format(nonEmptySummary).includes('‚Ä¢') === true
     */
    it('should contain bullet points (‚Ä¢) for any non-empty summary', () => {
      fc.assert(
        fc.property(nonEmptySummaryArbitrary, (rawSummary: string) => {
          const formatted = formatter.format(rawSummary);
          
          // Formatted output must contain bullet points
          expect(formatted).toContain(EMOJI.BULLET);
          
          return true;
        }),
        { numRuns: 100, verbose: true }
      );
    });

    /**
     * **Validates: Requirements 3.4**
     * 
     * For any summary that contains questions, the formatted output SHALL
     * contain the open questions section marker (‚ùì).
     * 
     * Property: format(summaryWithQuestions).includes('‚ùì') === true
     */
    it('should contain open questions section (‚ùì) when questions are present', () => {
      fc.assert(
        fc.property(summaryWithQuestionsArbitrary, (rawSummary: string) => {
          const formatted = formatter.format(rawSummary);
          
          // Formatted output must contain the questions section marker
          expect(formatted).toContain(EMOJI.QUESTION);
          
          // Questions section should include the header text
          expect(formatted).toContain(OPEN_QUESTIONS_HEADER);
          
          return true;
        }),
        { numRuns: 100, verbose: true }
      );
    });

    /**
     * **Validates: Requirements 3.4**
     * 
     * For any non-empty summary, the formatted output SHALL contain
     * the default header text.
     * 
     * Property: format(nonEmptySummary).includes(DEFAULT_HEADER) === true
     */
    it('should contain default header text for any non-empty summary', () => {
      fc.assert(
        fc.property(nonEmptySummaryArbitrary, (rawSummary: string) => {
          const formatted = formatter.format(rawSummary);
          
          // Formatted output must contain the default header
          expect(formatted).toContain(DEFAULT_HEADER);
          
          return true;
        }),
        { numRuns: 100, verbose: true }
      );
    });

    /**
     * **Validates: Requirements 3.4**
     * 
     * For any non-empty summary, the formatted output SHALL have
     * the header emoji followed by the header text on the first line.
     * 
     * Property: format(nonEmptySummary) starts with "üßµ Summary of recent discussion"
     */
    it('should have properly formatted header line', () => {
      fc.assert(
        fc.property(nonEmptySummaryArbitrary, (rawSummary: string) => {
          const formatted = formatter.format(rawSummary);
          const expectedHeader = `${EMOJI.HEADER} ${DEFAULT_HEADER}`;
          
          // First line should be the header
          const firstLine = formatted.split('\n')[0];
          expect(firstLine).toBe(expectedHeader);
          
          return true;
        }),
        { numRuns: 100, verbose: true }
      );
    });

    /**
     * **Validates: Requirements 3.4**
     * 
     * For any non-empty summary, each topic line in the formatted output
     * SHALL start with a bullet point (‚Ä¢).
     * 
     * Property: All content lines (excluding headers) start with '‚Ä¢'
     */
    it('should format all topic lines with bullet points', () => {
      fc.assert(
        fc.property(topicsOnlySummaryArbitrary, (rawSummary: string) => {
          const formatted = formatter.format(rawSummary);
          const lines = formatted.split('\n');
          
          // Find content lines (skip header and empty lines)
          const contentLines = lines.filter(line => 
            line.trim().length > 0 && 
            !line.startsWith(EMOJI.HEADER) &&
            !line.startsWith(EMOJI.QUESTION)
          );
          
          // All content lines should start with bullet point
          for (const line of contentLines) {
            expect(line.startsWith(EMOJI.BULLET)).toBe(true);
          }
          
          return true;
        }),
        { numRuns: 100, verbose: true }
      );
    });

    /**
     * **Validates: Requirements 3.4**
     * 
     * For any summary with questions, the questions section SHALL appear
     * after the topics section.
     * 
     * Property: Questions section (‚ùì) appears after at least one bullet point
     */
    it('should place questions section after topics section', () => {
      fc.assert(
        fc.property(summaryWithQuestionsArbitrary, (rawSummary: string) => {
          const formatted = formatter.format(rawSummary);
          
          const bulletIndex = formatted.indexOf(EMOJI.BULLET);
          const questionIndex = formatted.indexOf(EMOJI.QUESTION);
          
          // Both should be present
          expect(bulletIndex).toBeGreaterThan(-1);
          expect(questionIndex).toBeGreaterThan(-1);
          
          // Questions section should come after at least one bullet point
          expect(questionIndex).toBeGreaterThan(bulletIndex);
          
          return true;
        }),
        { numRuns: 100, verbose: true }
      );
    });

    /**
     * **Validates: Requirements 3.4**
     * 
     * Combined property test: For any non-empty summary, the formatted output
     * SHALL contain all required formatting elements.
     * 
     * This is the comprehensive test that validates the complete property.
     */
    it('should contain all required formatting elements for any non-empty summary', () => {
      fc.assert(
        fc.property(nonEmptySummaryArbitrary, (rawSummary: string) => {
          const formatted = formatter.format(rawSummary);
          
          // Must contain header emoji
          expect(formatted).toContain(EMOJI.HEADER);
          
          // Must contain bullet points
          expect(formatted).toContain(EMOJI.BULLET);
          
          // Must contain default header text
          expect(formatted).toContain(DEFAULT_HEADER);
          
          // Must start with header
          expect(formatted.startsWith(EMOJI.HEADER)).toBe(true);
          
          return true;
        }),
        { numRuns: 100, verbose: true }
      );
    });

    /**
     * **Validates: Requirements 3.4**
     * 
     * Edge case: Summaries with various input formats should all produce
     * properly formatted output.
     */
    it('should handle various input formats consistently', () => {
      const variousFormatsArbitrary = fc.oneof(
        bulletPointSummaryArbitrary,
        dashSummaryArbitrary,
        asteriskSummaryArbitrary,
        topicsOnlySummaryArbitrary
      );

      fc.assert(
        fc.property(variousFormatsArbitrary, (rawSummary: string) => {
          const formatted = formatter.format(rawSummary);
          
          // All formats should produce output with required elements
          expect(formatted).toContain(EMOJI.HEADER);
          expect(formatted).toContain(EMOJI.BULLET);
          expect(formatted).toContain(DEFAULT_HEADER);
          
          return true;
        }),
        { numRuns: 100, verbose: true }
      );
    });

    /**
     * **Validates: Requirements 3.4**
     * 
     * Edge case: Summaries with whitespace variations should still be
     * properly formatted.
     */
    it('should handle summaries with extra whitespace', () => {
      const whitespaceVariationArbitrary = fc.array(topicArbitrary, { minLength: 1, maxLength: 5 })
        .map(topics => topics.map(t => `  - ${t}  `).join('\n\n\n'));

      fc.assert(
        fc.property(whitespaceVariationArbitrary, (rawSummary: string) => {
          const formatted = formatter.format(rawSummary);
          
          // Should still contain required elements
          expect(formatted).toContain(EMOJI.HEADER);
          expect(formatted).toContain(EMOJI.BULLET);
          
          return true;
        }),
        { numRuns: 100, verbose: true }
      );
    });

    /**
     * **Validates: Requirements 3.4**
     * 
     * The formatted output should be non-empty for any non-empty input.
     */
    it('should produce non-empty output for any non-empty input', () => {
      fc.assert(
        fc.property(nonEmptySummaryArbitrary, (rawSummary: string) => {
          const formatted = formatter.format(rawSummary);
          
          // Output should not be empty
          expect(formatted.length).toBeGreaterThan(0);
          expect(formatted.trim().length).toBeGreaterThan(0);
          
          return true;
        }),
        { numRuns: 100, verbose: true }
      );
    });
  });
});
